<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <title>Jogo de Damas</title>
  <style>
    #board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      width: 480px;
      height: 480px;
      border: 2px solid black;
    }
    .cell {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .black { background-color: #444; }
    .white { background-color: #eee; }
    .piece {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
    }
    .white-piece { background-color: white; }
    .black-piece { background-color: black; }
    .highlight { outline: 2px solid yellow; }
  </style>
</head>
<body>
  <h2>Jogo de Damas</h2>
  <div id="board"></div>

  <script>
    const board = document.getElementById("board");
    let selectedPiece = null;
    let currentPlayer = "white";
    let gameState = Array(8).fill(null).map(() => Array(8).fill(null));

    function createBoard() {
      board.innerHTML = "";
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const cell = document.createElement("div");
          cell.classList.add("cell", (row + col) % 2 === 0 ? "white" : "black");
          cell.dataset.row = row;
          cell.dataset.col = col;
          board.appendChild(cell);
        }
      }
    }

    function placePieces() {
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 8; col++) {
          if ((row + col) % 2 !== 0) addPiece(row, col, "black");
        }
      }
      for (let row = 5; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if ((row + col) % 2 !== 0) addPiece(row, col, "white");
        }
      }
    }

    function addPiece(row, col, color) {
      const cell = getCell(row, col);
      const piece = document.createElement("div");
      piece.classList.add("piece", `${color}-piece`);
      piece.dataset.row = row;
      piece.dataset.col = col;
      piece.dataset.color = color;
      cell.appendChild(piece);
      gameState[row][col] = color;
    }

    function getCell(row, col) {
      return board.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    }

    function getPiece(row, col) {
      const cell = getCell(row, col);
      return cell.querySelector(".piece");
    }

        function movePiece(piece, toRow, toCol) {
      const fromRow = parseInt(piece.dataset.row);
      const fromCol = parseInt(piece.dataset.col);
      const capturedRow = (fromRow + toRow) / 2;
      const capturedCol = (fromCol + toCol) / 2;

      // Remove peça capturada se for um movimento de captura
      if (Math.abs(toRow - fromRow) === 2) {
        const capturedPiece = getPiece(capturedRow, capturedCol);
        if (capturedPiece) capturedPiece.remove();
        gameState[capturedRow][capturedCol] = null;
      }

      // Atualiza DOM e estado lógico
      getCell(fromRow, fromCol).innerHTML = "";
      getCell(toRow, toCol).appendChild(piece);
      piece.dataset.row = toRow;
      piece.dataset.col = toCol;

      gameState[fromRow][fromCol] = null;
      gameState[toRow][toCol] = piece.dataset.color;

      // Verifica se há captura adicional
      if (Math.abs(toRow - fromRow) === 2) {
        const moreCaptures = getValidCaptures(toRow, toCol, piece.dataset.color);
        if (moreCaptures.length > 0) {
          highlightMoves(piece, moreCaptures);
          selectedPiece = piece;
          return;
        }
      }

      selectedPiece = null;
      currentPlayer = currentPlayer === "white" ? "black" : "white";
      if (currentPlayer === "black") setTimeout(aiMove, 500);
    }

    function getValidMoves(row, col, color) {
      const directions = color === "white" ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]];
      const moves = [];

      directions.forEach(([dx, dy]) => {
        const newRow = row + dx;
        const newCol = col + dy;
        if (isInBounds(newRow, newCol) && !gameState[newRow][newCol]) {
          moves.push([newRow, newCol]);
        }
      });

      return moves;
    }

    function getValidCaptures(row, col, color) {
      const directions = color === "white" ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]];
      const captures = [];

      directions.forEach(([dx, dy]) => {
        const midRow = row + dx;
        const midCol = col + dy;
        const newRow = row + 2 * dx;
        const newCol = col + 2 * dy;

        if (
          isInBounds(newRow, newCol) &&
          gameState[midRow][midCol] &&
          gameState[midRow][midCol] !== color &&
          !gameState[newRow][newCol]
        ) {
          captures.push([newRow, newCol]);
        }
      });

      return captures;
    }

    function isInBounds(row, col) {
      return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    function highlightMoves(piece, moves) {
      clearHighlights();
      moves.forEach(([row, col]) => {
        const cell = getCell(row, col);
        cell.classList.add("highlight");
        cell.onclick = () => movePiece(piece, row, col);
      });
    }

    function clearHighlights() {
      document.querySelectorAll(".highlight").forEach(cell => {
        cell.classList.remove("highlight");
        cell.onclick = null;
      });
    }

    board.addEventListener("click", e => {
      const piece = e.target.closest(".piece");
      if (!piece || piece.dataset.color !== currentPlayer) return;

      const row = parseInt(piece.dataset.row);
      const col = parseInt(piece.dataset.col);
      const captures = getValidCaptures(row, col, currentPlayer);

      if (captures.length > 0) {
        highlightMoves(piece, captures);
      } else {
        const moves = getValidMoves(row, col, currentPlayer);
        highlightMoves(piece, moves);
      }

      selectedPiece = piece;
    });

        function aiMove() {
      const moves = getAllPossibleMoves("black");
      if (moves.length === 0) return;

      // Prioriza capturas
      const captureMoves = moves.filter(m => m.capture);
      const move = captureMoves.length > 0 ? captureMoves[0] : moves[0];

      const piece = getPiece(move.from[0], move.from[1]);
      movePiece(piece, move.to[0], move.to[1]);
    }

    function getAllPossibleMoves(color) {
      const moves = [];

      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (gameState[row][col] === color) {
            const captures = getValidCaptures(row, col, color);
            if (captures.length > 0) {
              captures.forEach(([r, c]) => {
                moves.push({ from: [row, col], to: [r, c], capture: true });
              });
            } else {
              const regularMoves = getValidMoves(row, col, color);
              regularMoves.forEach(([r, c]) => {
                moves.push({ from: [row, col], to: [r, c], capture: false });
              });
            }
          }
        }
      }

      return moves;
    }

    function cloneGameState() {
      return gameState.map(row => row.slice());
    }

    function simulateMove(state, fromRow, fromCol, toRow, toCol, color) {
      const newState = cloneGameState();
      newState[fromRow][fromCol] = null;
      newState[toRow][toCol] = color;

      if (Math.abs(toRow - fromRow) === 2) {
        const midRow = (fromRow + toRow) / 2;
        const midCol = (fromCol + toCol) / 2;
        newState[midRow][midCol] = null;
      }

      return newState;
    }

    // Inicializa o jogo
    createBoard();
    placePieces();
  </script>
</body>
</html>